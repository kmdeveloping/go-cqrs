package main

import (
	"errors"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type Handler struct {
	Name       string
	Type       string // "Command", "Query", "Event", or "Validator"
	ImportPath string
}

func main() {
	// Get the project root where the app is executed from
	projectRoot, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	// Find handlers directory (case insensitive)
	handlersDir, err := findHandlersDir(projectRoot)
	if err != nil {
		log.Fatalf("Failed to find handlers directory: %v", err)
	}

	// Get module path
	modulePath, err := getModulePath(projectRoot)
	if err != nil {
		log.Fatalf("Failed to determine module path: %v", err)
	}

	// Determine handlers import path
	relHandlersPath, err := filepath.Rel(projectRoot, handlersDir)
	if err != nil {
		log.Fatalf("Failed to determine relative handlers path: %v", err)
	}

	// Convert Windows path separators to Go import path separator '/'
	relHandlersPath = strings.ReplaceAll(relHandlersPath, "\\", "/")
	handlersImportPath := modulePath
	if relHandlersPath != "." {
		handlersImportPath = modulePath + "/" + relHandlersPath
	}

	// Parse handlers
	handlers, err := parseHandlers(handlersDir, handlersImportPath)
	if err != nil {
		log.Fatal(err)
	}

	if len(handlers) == 0 {
		log.Fatalf("No handlers found in %s", handlersDir)
	}

	// Generate the code
	if err := generateCode(handlers, projectRoot, handlersImportPath); err != nil {
		log.Fatal(err)
	}

	log.Printf("Successfully generated handler registry at %s", filepath.Join(projectRoot, "registry_gen.go"))
}

// Discover module path from go.mod file
func getModulePath(projectRoot string) (string, error) {
	modFile, err := os.ReadFile(filepath.Join(projectRoot, "go.mod"))
	if err != nil {
		return "", err
	}

	// Get first line and extract module path
	lines := strings.Split(string(modFile), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module ")), nil
		}
	}

	return "", errors.New("could not determine module path from go.mod")
}

// findHandlersDir finds a directory named "handlers" (case insensitive) in the project root
func findHandlersDir(projectRoot string) (string, error) {
	var handlersDir string

	err := filepath.WalkDir(projectRoot, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Skip hidden directories and common build directories
		if d.IsDir() {
			name := d.Name()
			if name[0] == '.' || name == "vendor" || name == "node_modules" {
				return filepath.SkipDir
			}
		}

		// Check if it's a directory with a name that matches "handlers" case-insensitively
		if d.IsDir() && strings.ToLower(d.Name()) == "handlers" {
			rel, err := filepath.Rel(projectRoot, path)
			if err == nil && rel != "." && !strings.HasPrefix(rel, "..") {
				handlersDir = path
				// Don't return filepath.SkipAll as it might not be available in all Go versions
				// Continue search in case there are multiple handlers directories
			}
		}

		return nil
	})

	if err != nil {
		return "", err
	}

	if handlersDir == "" {
		return "", errors.New("could not find handlers directory")
	}

	return handlersDir, nil
}

func parseHandlers(dir string, importPath string) ([]Handler, error) {
	var handlers []Handler

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, 0)
	if err != nil {
		return nil, err
	}

	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				if genDecl, ok := decl.(*ast.GenDecl); ok {
					for _, spec := range genDecl.Specs {
						if typeSpec, ok := spec.(*ast.TypeSpec); ok {
							name := typeSpec.Name.Name
							if strings.HasSuffix(name, "Handler") || strings.HasSuffix(name, "Validator") {
								handlerType := getHandlerType(name)
								if handlerType != "" {
									handlers = append(handlers, Handler{
										Name:       name,
										Type:       handlerType,
										ImportPath: importPath,
									})
								}
							}
						}
					}
				}
			}
		}
	}

	return handlers, nil
}

func getHandlerType(name string) string {
	switch {
	case strings.HasSuffix(name, "CommandHandler"):
		return "Command"
	case strings.HasSuffix(name, "QueryHandler"):
		return "Query"
	case strings.HasSuffix(name, "EventHandler"):
		return "Event"
	case strings.HasSuffix(name, "Validator"):
		return "Validator"
	default:
		return ""
	}
}

const codeTemplate = `// Code generated by gen-handler-registry. DO NOT EDIT.

package main

import (
	"github.com/kmdeveloping/go-cqrs/cqrs"
	"{{ .ImportPath }}"
)

func registerHandlers() {
	// Register handlers
	{{- range .Handlers }}
	{{- if ne .Type "Validator" }}
	cqrs.Register{{ .Type }}Handler(&handlers.{{ .Name }}{})
	{{- else }}
	cqrs.RegisterValidator(&handlers.{{ .Name }}{})
	{{- end }}
	{{- end }}
}
`

func generateCode(handlers []Handler, projectRoot string, handlersImportPath string) error {
	tmpl, err := template.New("registry").Parse(codeTemplate)
	if err != nil {
		return err
	}

	// Create output file
	outFile := filepath.Join(projectRoot, "registry_gen.go")
	f, err := os.Create(outFile)
	if err != nil {
		return err
	}
	defer f.Close()

	data := struct {
		Handlers   []Handler
		ImportPath string
	}{
		Handlers:   handlers,
		ImportPath: handlersImportPath,
	}

	return tmpl.Execute(f, data)
}
