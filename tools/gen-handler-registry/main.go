package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type Handler struct {
	Name       string
	Type       string // "Command", "Query", "Event", or "Validator"
	ImportPath string
}

func main() {
	// Get the project root (assuming this script is in tools/gen-handler-registry)
	projectRoot, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	// Path to handlers directory
	handlersDir := filepath.Join(projectRoot, "handlers")

	// Parse handlers
	handlers, err := parseHandlers(handlersDir)
	if err != nil {
		log.Fatal(err)
	}

	// Generate the code
	if err := generateCode(handlers, projectRoot); err != nil {
		log.Fatal(err)
	}
}

func parseHandlers(dir string) ([]Handler, error) {
	var handlers []Handler

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, 0)
	if err != nil {
		return nil, err
	}

	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				if genDecl, ok := decl.(*ast.GenDecl); ok {
					for _, spec := range genDecl.Specs {
						if typeSpec, ok := spec.(*ast.TypeSpec); ok {
							name := typeSpec.Name.Name
							if strings.HasSuffix(name, "Handler") || strings.HasSuffix(name, "Validator") {
								handlerType := getHandlerType(name)
								if handlerType != "" {
									handlers = append(handlers, Handler{
										Name:       name,
										Type:       handlerType,
										ImportPath: "github.com/kmdeveloping/go-cqrs/example/handlers",
									})
								}
							}
						}
					}
				}
			}
		}
	}

	return handlers, nil
}

func getHandlerType(name string) string {
	switch {
	case strings.HasSuffix(name, "CommandHandler"):
		return "Command"
	case strings.HasSuffix(name, "QueryHandler"):
		return "Query"
	case strings.HasSuffix(name, "EventHandler"):
		return "Event"
	case strings.HasSuffix(name, "Validator"):
		return "Validator"
	default:
		return ""
	}
}

const codeTemplate = `// Code generated by gen-handler-registry. DO NOT EDIT.

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strings"

	"github.com/kmdeveloping/go-cqrs/cqrs"
	"{{ .ImportPath }}"
)

func BootstrapCqrs() {
	m := cqrs.NewCqrsManager()
	m.UseDefaultDecorators()
	autoRegisterHandlers()
}

func autoRegisterHandlers() {
	types := getHandlerNames()
	for _, typeName := range types {
		switch typeName {
		{{- range .Handlers }}
		case "{{ .Name }}":
			handler := &handlers.{{ .Name }}{}
			{{- if eq .Type "Command" }}
			cqrs.RegisterCommandHandler(handler)
			{{- else if eq .Type "Query" }}
			cqrs.RegisterQueryHandler(handler)
			{{- else if eq .Type "Event" }}
			cqrs.RegisterEventHandler(handler)
			{{- else if eq .Type "Validator" }}
			cqrs.RegisterValidator(handler)
			{{- end }}
		{{- end }}
		default:
			fmt.Printf("Unknown handler type: %s\n", typeName)
		}
	}
}

// getHandlerNames returns a list of handler type names by parsing Go files
func getHandlerNames() []string {
	var handlers []string

	// Set up the file set
	fset := token.NewFileSet()

	// Parse the handlers directory
	pkgs, err := parser.ParseDir(fset, "handlers", nil, 0)
	if err != nil {
		return []string{}
	}

	// Iterate through all packages
	for _, pkg := range pkgs {
		// Iterate through all files in the package
		for _, file := range pkg.Files {
			// Look for type declarations
			for _, decl := range file.Decls {
				if genDecl, ok := decl.(*ast.GenDecl); ok {
					for _, spec := range genDecl.Specs {
						if typeSpec, ok := spec.(*ast.TypeSpec); ok {
							typeName := typeSpec.Name.Name
							// Only add types that end with Handler or Validator
							if strings.HasSuffix(typeName, "Handler") ||
								strings.HasSuffix(typeName, "Validator") {
								handlers = append(handlers, typeName)
							}
						}
					}
				}
			}
		}
	}

	return handlers
}
`

func generateCode(handlers []Handler, projectRoot string) error {
	tmpl, err := template.New("registry").Parse(codeTemplate)
	if err != nil {
		return err
	}

	// Create output file
	outFile := filepath.Join(projectRoot, "startup.go")
	f, err := os.Create(outFile)
	if err != nil {
		return err
	}
	defer f.Close()

	data := struct {
		Handlers   []Handler
		ImportPath string
	}{
		Handlers:   handlers,
		ImportPath: handlers[0].ImportPath,
	}

	return tmpl.Execute(f, data)
}
